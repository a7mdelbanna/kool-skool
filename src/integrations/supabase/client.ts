// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://clacmtyxfdtfgjkozmqf.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsYWNtdHl4ZmR0Zmdqa296bXFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4OTEzMzgsImV4cCI6MjA2NjQ2NzMzOH0.HKKmBmDpQdZ7-hcpj7wM8IJPFVD52T-IfThF9jpjdvY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Type definitions for the application
export interface UserLoginResponse {
  success: boolean;
  message?: string;
  user_id?: string;
  first_name?: string;
  last_name?: string;
  role?: string;
  school_id?: string;
}

export interface SchoolSetupResponse {
  success: boolean;
  message?: string;
  school_id?: string;
  user_id?: string;
}

export interface TeamMemberResponse {
  success: boolean;
  message?: string;
  user_id?: string;
}

export interface CreateStudentResponse {
  success: boolean;
  message?: string;
  student_id?: string;
  user_id?: string;
}

export interface Course {
  id: string;
  school_id: string;
  name: string;
  lesson_type: string;
  created_at: string;
  updated_at: string;
}

export interface StudentRecord {
  id: string;
  school_id: string;
  user_id: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone: string;
  created_at: string;
  first_name: string;
  last_name: string;
  email: string;
  course_name: string;
  lesson_type: string;
  teacher_first_name: string;
  teacher_last_name: string;
  teacher_email: string;
}

// Helper functions for interacting with the database
export const getStudentsWithDetails = async (schoolId: string): Promise<StudentRecord[]> => {
  const { data, error } = await supabase.rpc('get_students_with_details', {
    p_school_id: schoolId
  });

  if (error) {
    console.error('Error fetching students:', error);
    throw error;
  }

  return data || [];
};

export const getSchoolCourses = async (schoolId: string): Promise<Course[]> => {
  console.log('getSchoolCourses called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS
    const { data, error } = await supabase.rpc('get_school_courses', {
      p_school_id: schoolId
    });

    console.log('RPC get_school_courses result:', { data, error });

    if (error) {
      console.error('Error fetching courses via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched courses:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolCourses:', error);
    throw error;
  }
};

export const getSchoolTeamMembers = async (schoolId: string) => {
  console.log('getSchoolTeamMembers called with schoolId:', schoolId);
  
  try {
    // Use the database function instead of direct query
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Team members RPC result:', { data, error });

    if (error) {
      console.error('Error fetching team members via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched team members:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolTeamMembers:', error);
    throw error;
  }
};

export const getSchoolTeachers = async (schoolId: string) => {
  console.log('getSchoolTeachers called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS consistently
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Teachers RPC result:', { data, error });

    if (error) {
      console.error('Error fetching teachers via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched teachers:', data);
    
    // Filter only teachers and format for compatibility
    const teachers = (data || [])
      .filter(member => member.role === 'teacher')
      .map(teacher => ({
        id: teacher.id,
        first_name: teacher.first_name || '',
        last_name: teacher.last_name || '',
        email: teacher.email || '',
        display_name: teacher.first_name && teacher.last_name 
          ? `${teacher.first_name} ${teacher.last_name}`
          : teacher.email || `ID: ${teacher.id.substring(0, 8)}`
      }));

    console.log('Formatted teachers:', teachers);
    return teachers;
  } catch (error) {
    console.error('Error in getSchoolTeachers:', error);
    throw error;
  }
};

export const getStudentPayments = async (studentId: string) => {
  console.log('getStudentPayments called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_payments', {
      p_student_id: studentId
    });

    console.log('Student payments RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student payments:', error);
      throw error;
    }

    console.log('Successfully fetched student payments:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentPayments:', error);
    throw error;
  }
};

export const addStudentPayment = async (paymentData: {
  student_id: string;
  amount: number;
  currency: string;
  payment_date: string;
  payment_method: string;
  status: string;
  notes?: string;
}) => {
  console.log('addStudentPayment called with:', paymentData);
  
  try {
    const { data, error } = await supabase
      .from('student_payments')
      .insert(paymentData)
      .select()
      .single();

    if (error) {
      console.error('Error adding student payment:', error);
      throw error;
    }

    console.log('Successfully added student payment:', data);
    return data;
  } catch (error) {
    console.error('Error in addStudentPayment:', error);
    throw error;
  }
};

export const deleteStudentPayment = async (paymentId: string) => {
  console.log('deleteStudentPayment called with paymentId:', paymentId);
  
  try {
    const { error } = await supabase
      .from('student_payments')
      .delete()
      .eq('id', paymentId);

    if (error) {
      console.error('Error deleting student payment:', error);
      throw error;
    }

    console.log('Successfully deleted student payment');
  } catch (error) {
    console.error('Error in deleteStudentPayment:', error);
    throw error;
  }
};

export const getStudentSubscriptions = async (studentId: string) => {
  console.log('getStudentSubscriptions called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_subscriptions', {
      p_student_id: studentId
    });

    console.log('Student subscriptions RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student subscriptions:', error);
      throw error;
    }

    console.log('Successfully fetched student subscriptions:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentSubscriptions:', error);
    throw error;
  }
};

// Global tracking for subscription creation to prevent duplicates
const subscriptionCreationTracker = new Map<string, boolean>();

export const addStudentSubscription = async (subscriptionData: {
  student_id: string;
  session_count: number;
  duration_months: number;
  start_date: string;
  schedule: any;
  price_mode: string;
  price_per_session?: number;
  fixed_price?: number;
  total_price: number;
  currency: string;
  notes?: string;
  status?: string;
}) => {
  // Create a unique key for this subscription request
  const subscriptionKey = `${subscriptionData.student_id}-${subscriptionData.start_date}-${subscriptionData.session_count}-${JSON.stringify(subscriptionData.schedule)}`;
  
  console.log('🔍 DUPLICATE PREVENTION: Checking for ongoing subscription creation:', subscriptionKey);
  
  // Check if this exact subscription is already being created
  if (subscriptionCreationTracker.has(subscriptionKey)) {
    console.error('🚫 DUPLICATE CALL PREVENTED: Subscription creation already in progress for:', subscriptionKey);
    throw new Error('Subscription creation already in progress. Please wait.');
  }
  
  // Mark this subscription as being created
  subscriptionCreationTracker.set(subscriptionKey, true);
  
  try {
    console.log('=== STARTING SUBSCRIPTION CREATION WITH DUPLICATE PREVENTION ===');
    console.log('addStudentSubscription called with DUPLICATE PREVENTION:', subscriptionData);
    
    // Get current user from localStorage for validation
    const userString = localStorage.getItem('user');
    if (!userString) {
      throw new Error('User not authenticated');
    }
    
    const user = JSON.parse(userString);
    console.log('Current user for subscription:', user);
    
    console.log('=== CALLING FIXED add_student_subscription RPC WITH DUPLICATE PREVENTION ===');
    console.log('About to call add_student_subscription RPC with parameters:', {
      p_student_id: subscriptionData.student_id,
      p_session_count: subscriptionData.session_count,
      p_duration_months: subscriptionData.duration_months,
      p_start_date: subscriptionData.start_date,
      p_schedule: subscriptionData.schedule,
      p_current_user_id: user.id,
      p_current_school_id: user.schoolId
    });
    
    // Add a small delay to prevent rapid successive calls
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Use the fixed RPC function with comprehensive duplicate prevention
    const { data, error } = await supabase.rpc('add_student_subscription', {
      p_student_id: subscriptionData.student_id,
      p_session_count: subscriptionData.session_count,
      p_duration_months: subscriptionData.duration_months,
      p_start_date: subscriptionData.start_date,
      p_schedule: subscriptionData.schedule,
      p_price_mode: subscriptionData.price_mode,
      p_price_per_session: subscriptionData.price_per_session || null,
      p_fixed_price: subscriptionData.fixed_price || null,
      p_total_price: subscriptionData.total_price,
      p_currency: subscriptionData.currency,
      p_notes: subscriptionData.notes || null,
      p_status: subscriptionData.status || 'active',
      p_current_user_id: user.id,
      p_current_school_id: user.schoolId
    });

    if (error) {
      console.error('❌ Error adding student subscription via RPC:', error);
      
      // Enhanced error handling
      if (error.message && error.message.includes('duplicate key value violates unique constraint')) {
        throw new Error('Cannot create subscription: A session already exists at this time. Please choose a different schedule.');
      }
      
      if (error.message && error.message.includes('Duplicate session prevented')) {
        throw new Error('Cannot create subscription: Some sessions would conflict with existing ones. Please check the student\'s current schedule.');
      }
      
      // Generic error fallback
      throw new Error(error.message || 'Failed to create subscription');
    }

    if (!data || (Array.isArray(data) && data.length === 0)) {
      throw new Error('Subscription creation failed: No data returned from server');
    }

    console.log('✅ Successfully added student subscription with duplicate prevention:', data);
    console.log('🎉 SUBSCRIPTION CREATED SUCCESSFULLY with client-side duplicate prevention');
    
    // Return the first item from the array since RPC returns an array
    return Array.isArray(data) && data.length > 0 ? data[0] : data;
  } catch (error) {
    console.error('❌ Error in addStudentSubscription with duplicate prevention:', error);
    
    // Re-throw with more context if it's a generic error
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('An unexpected error occurred while creating the subscription');
  } finally {
    // Always remove the tracking key after completion (success or failure)
    console.log('🧹 CLEANUP: Removing subscription creation tracking for:', subscriptionKey);
    subscriptionCreationTracker.delete(subscriptionKey);
  }
};

export const deleteStudentSubscription = async (subscriptionId: string) => {
  console.log('🗑️ ENHANCED deleteStudentSubscription called with subscriptionId:', subscriptionId);
  
  if (!subscriptionId) {
    console.error('❌ No subscription ID provided');
    throw new Error('Subscription ID is required');
  }
  
  try {
    // First, let's check if the subscription exists and get its details
    console.log('🔍 Checking if subscription exists before deletion...');
    const { data: existingSubscription, error: checkError } = await supabase
      .from('subscriptions')
      .select('id, student_id')
      .eq('id', subscriptionId)
      .single();

    if (checkError) {
      console.error('❌ Error checking subscription existence:', checkError);
      throw new Error(`Failed to verify subscription: ${checkError.message}`);
    }

    if (!existingSubscription) {
      console.log('⚠️ Subscription not found, may have been already deleted');
      return; // Already deleted, no error needed
    }

    console.log('✅ Found subscription to delete:', existingSubscription);

    // Delete associated lesson sessions first (if any exist)
    console.log('🗑️ Deleting associated lesson sessions...');
    const { error: sessionsError } = await supabase
      .from('lesson_sessions')
      .delete()
      .eq('subscription_id', subscriptionId);

    if (sessionsError) {
      console.error('❌ Error deleting lesson sessions:', sessionsError);
      // Don't throw here, continue with subscription deletion
      console.log('⚠️ Continuing with subscription deletion despite session deletion error');
    } else {
      console.log('✅ Successfully deleted associated lesson sessions');
    }

    // Now delete the subscription
    console.log('🗑️ Deleting subscription from database...');
    const { error: deleteError, data } = await supabase
      .from('subscriptions')
      .delete()
      .eq('id', subscriptionId)
      .select(); // This will return the deleted record(s)

    if (deleteError) {
      console.error('❌ Error deleting subscription:', deleteError);
      throw new Error(`Failed to delete subscription: ${deleteError.message}`);
    }

    // Verify the deletion worked
    if (!data || data.length === 0) {
      console.error('❌ Subscription deletion failed - no records were deleted');
      throw new Error('Subscription deletion failed - no records were affected');
    }

    console.log('✅ Successfully deleted subscription:', data);
    console.log('🎉 ENHANCED DELETION COMPLETED SUCCESSFULLY');

    // Double-check by trying to fetch the deleted subscription
    console.log('🔍 Verifying deletion by attempting to fetch deleted subscription...');
    const { data: verifyData, error: verifyError } = await supabase
      .from('subscriptions')
      .select('id')
      .eq('id', subscriptionId)
      .single();

    if (verifyError && verifyError.code === 'PGRST116') {
      console.log('✅ Deletion verified - subscription no longer exists');
    } else if (verifyData) {
      console.error('❌ CRITICAL: Subscription still exists after deletion!', verifyData);
      throw new Error('Subscription deletion failed - record still exists in database');
    }

  } catch (error) {
    console.error('❌ Error in enhanced deleteStudentSubscription:', error);
    
    // Re-throw with more context if it's a generic error
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('An unexpected error occurred while deleting the subscription');
  }
};

export const addLessonSessions = async (sessions: Array<{
  subscription_id: string;
  student_id: string;
  scheduled_date: string;
  duration_minutes?: number;
  status?: string;
  payment_status?: string;
  cost: number;
  notes?: string;
}>) => {
  console.log('addLessonSessions called with enhanced duplicate prevention:', sessions);
  
  try {
    const { data, error } = await supabase
      .from('lesson_sessions')
      .insert(sessions)
      .select();

    if (error) {
      console.error('Error adding lesson sessions with enhanced prevention:', error);
      throw error;
    }

    console.log('Successfully added lesson sessions with enhanced prevention:', data);
    return data;
  } catch (error) {
    console.error('Error in addLessonSessions with enhanced prevention:', error);
    throw error;
  }
};

export const getStudentLessonSessions = async (studentId: string) => {
  console.log('getStudentLessonSessions called with COMPREHENSIVE VALIDATION for studentId:', studentId);
  
  try {
    // Enhanced logging for session retrieval with comprehensive database structure
    console.log('=== FETCHING SESSIONS WITH COMPREHENSIVE VALIDATION ===');
    console.log('Fetching lesson sessions for student:', studentId);
    
    // Use direct RPC call with comprehensive error handling
    const { data, error } = await supabase.rpc('get_lesson_sessions' as any, {
      p_student_id: studentId
    });

    console.log('Lesson sessions RPC result with comprehensive validation:', { data, error });

    if (error) {
      console.error('❌ Error fetching lesson sessions via RPC:', error);
      throw error;
    }

    // Comprehensive logging and validation for retrieved sessions
    if (data && data.length > 0) {
      console.log(`✅ Successfully fetched ${data.length} lesson sessions with comprehensive validation`);
      
      // Comprehensive session validation and logging
      const sessionSummary = data.map((session, index) => ({
        position: index + 1,
        id: session.id,
        scheduled_date: session.scheduled_date,
        status: session.status,
        notes: session.notes,
        index_in_sub: session.index_in_sub,
        subscription_id: session.subscription_id
      }));
      
      console.log('Comprehensive session summary:', sessionSummary);
      
      // Comprehensive duplicate detection with database constraint validation
      const dateMap = new Map();
      const duplicates: any[] = [];
      
      data.forEach((session, index) => {
        const dateKey = session.scheduled_date;
        if (dateMap.has(dateKey)) {
          console.error('🚫 CRITICAL: Duplicate session detected - Database constraints failed!', {
            position: index + 1,
            existing: dateMap.get(dateKey),
            duplicate: session,
            message: 'This should not happen with the comprehensive database constraints'
          });
          duplicates.push(session);
        } else {
          dateMap.set(dateKey, session);
        }
      });
      
      if (duplicates.length > 0) {
        console.error('🚨 CRITICAL DATABASE INTEGRITY ISSUE:', {
          duplicateCount: duplicates.length,
          message: 'Database constraints and triggers are not working as expected',
          duplicates: duplicates
        });
      } else {
        console.log('✅ ALL SESSIONS VALIDATED - Comprehensive duplicate prevention working correctly');
      }
      
    } else {
      console.log('ℹ️  No lesson sessions found for student:', studentId);
    }

    return data || [];
  } catch (error) {
    console.error('❌ Error in getStudentLessonSessions with comprehensive validation:', error);
    throw error;
  }
};

export const updateLessonSessionStatus = async (sessionId: string, status: string) => {
  console.log('updateLessonSessionStatus called with:', { sessionId, status });
  
  try {
    const { error } = await supabase
      .from('lesson_sessions')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('id', sessionId);

    if (error) {
      console.error('Error updating lesson session status:', error);
      throw error;
    }

    console.log('Successfully updated lesson session status');
  } catch (error) {
    console.error('Error in updateLessonSessionStatus:', error);
    throw error;
  }
};

export const createStudent = async (studentData: {
  student_email: string;
  student_password: string;
  first_name: string;
  last_name: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone?: string;
}): Promise<CreateStudentResponse> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_student`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(studentData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};

export const createCourse = async (courseData: {
  school_id: string;
  course_name: string;
  lesson_type: string;
}): Promise<Course> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_course`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(courseData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};


// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://cfacqfrutwfbfibswckp.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNmYWNxZnJ1dHdmYmZpYnN3Y2twIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIwOTQ2MzMsImV4cCI6MjA1NzY3MDYzM30.QuxaZKXmhvdCLDUlVRA7Pge0JLm2EHl4qRApoGuevcE";

// Get the current URL to use as the site URL for auth redirects
const getSiteUrl = () => {
  let url = window.location.origin;
  // Remove any trailing slash
  if (url.endsWith('/')) {
    url = url.slice(0, -1);
  }
  return url;
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      flowType: 'pkce',
      autoRefreshToken: true,
      detectSessionInUrl: true,
      persistSession: true,
      // Use dynamic site URL for authentication flows
      // Corrected property for Supabase v2.x
      redirectTo: getSiteUrl()
    }
  }
);

// Type utility for safely accessing properties
const safeAccess = <T, K extends keyof T>(obj: T | null | undefined, key: K): T[K] | undefined => {
  return obj && key in obj ? obj[key] : undefined;
};

// Type guard to check if an object has a property
const hasProperty = <T>(obj: any, prop: string): obj is T => {
  return obj && typeof obj === 'object' && prop in obj;
};

// Helper function to upload base64 image to schools
export const uploadBase64Image = async (
  base64String: string, 
  schoolId: string, 
  field: 'logo' | 'phone' | 'telegram' | 'whatsapp' | 'instagram'
) => {
  const updateData: Record<string, string> = { [field]: base64String };
  
  const { data, error } = await supabase
    .from('schools')
    .update(updateData as any)
    .eq('id', schoolId as any);
    
  return { data, error };
};

// Helper function to fetch user profile data
export const fetchUserProfile = async () => {
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    throw new Error('No user authenticated');
  }
  
  // Add debug logging to see what data is coming from Supabase
  console.log("Auth user data:", user);
  
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', user.id as any)
    .single();
    
  if (error) {
    console.error("Error fetching profile:", error);
    throw error;
  }
  
  console.log("Profile data from database:", data);
  
  // Ensure we have valid data with safe access
  return { 
    user, 
    profile: data && {
      first_name: safeAccess(data, 'first_name'),
      last_name: safeAccess(data, 'last_name'),
      email: safeAccess(data, 'email'),
      phone: safeAccess(data, 'phone'),
      profile_picture: safeAccess(data, 'profile_picture'),
      id: safeAccess(data, 'id')
    } 
  };
};

// Helper function to update user profile
export const updateUserProfile = async (
  profileData: {
    first_name?: string;
    last_name?: string;
    phone?: string;
    profile_picture?: string | null;
  }
) => {
  const { data: { user } } = await supabase.auth.getUser();
  
  if (!user) {
    throw new Error('No user authenticated');
  }
  
  const { data, error } = await supabase
    .from('profiles')
    .update(profileData as any)
    .eq('id', user.id as any);
    
  if (error) {
    throw error;
  }
  
  return data;
};

// More accurate helper function to check if an email exists
const checkEmailExists = async (email: string) => {
  try {
    // Method 1: Check directly in auth.users using an admin function
    // Since we can't directly query auth.users from the client, we need to use an RPC
    // This approach would require a database function, but let's try the other methods first
    
    // Method 2: Check profiles table which is linked to auth users
    const { count: profileCount, error: countError } = await supabase
      .from('profiles')
      .select('id', { count: 'exact', head: true })
      .eq('email', email as any);
    
    if (countError) {
      console.error("Error checking profiles count for email:", countError);
    } else if (profileCount && profileCount > 0) {
      console.log(`Found ${profileCount} entries with email ${email} in profiles table`);
      return true;
    }

    // Method 3: Check team_members table
    const { count: teamMemberCount, error: teamMemberError } = await supabase
      .from('team_members')
      .select('id', { count: 'exact', head: true })
      .eq('email', email as any);
      
    if (teamMemberError) {
      console.error("Error checking team_members for email:", teamMemberError);
    } else if (teamMemberCount && teamMemberCount > 0) {
      console.log(`Found ${teamMemberCount} entries with email ${email} in team_members table`);
      return true;
    }
    
    // No evidence that the email exists in our system
    console.log(`No evidence that email ${email} exists in our system`);
    return false;
  } catch (error) {
    console.error("Error checking email existence:", error);
    return false; // Default to false to avoid blocking valid users
  }
};

// Helper function to invite a team member via email
export const inviteTeamMember = async (
  userData: {
    email: string;
    role: "director" | "teacher" | "admin" | "staff";
    firstName?: string;
    lastName?: string;
  }
) => {
  try {
    // Log the attempted invitation for debugging
    console.log("Inviting team member with data:", userData);
    
    // First check if the email already exists
    const emailExists = await checkEmailExists(userData.email);
    
    if (emailExists) {
      console.log(`Email ${userData.email} already exists, stopping invitation process`);
      throw new Error(`The email ${userData.email} is already registered. Please use a different email address.`);
    }
    
    // Use the invite_team_member RPC function to create the invitation
    const { data, error } = await supabase.rpc(
      'invite_team_member',
      {
        email_param: userData.email,
        role_param: userData.role,
        first_name_param: userData.firstName || null,
        last_name_param: userData.lastName || null
      }
    );
    
    if (error) {
      console.error("Error inviting team member:", error);
      throw error;
    }
    
    // Log the success
    console.log("Team member invited successfully:", data);
    
    // Now send invitation email via Supabase auth
    const { error: inviteError } = await supabase.auth.signInWithOtp({
      email: userData.email,
      options: {
        // Set data to pass to the invite_team_member function
        data: {
          invitation: true,
          role: userData.role
        },
        // Use the current origin as redirect URL
        emailRedirectTo: `${getSiteUrl()}/auth?type=invite`
      }
    });
    
    if (inviteError) {
      console.error("Error sending invitation email:", inviteError);
      throw inviteError;
    }
    
    return data;
  } catch (error) {
    console.error("Exception inviting team member:", error);
    throw error;
  }
};

// Legacy function kept for compatibility
export const createTeamMember = async (
  userData: {
    email: string;
    password: string;
    role: "director" | "teacher" | "admin" | "staff";
    firstName?: string;
    lastName?: string;
  }
) => {
  try {
    // Log the attempted creation for debugging
    console.log("Creating team member with data:", userData);
    console.log("Attempting to create team member with email:", userData.email);
    
    // First check if the email already exists
    const emailExists = await checkEmailExists(userData.email);
    
    if (emailExists) {
      console.log(`Email ${userData.email} already exists, stopping creation process`);
      throw new Error(`The email ${userData.email} is already registered. Please use a different email address.`);
    }
    
    // Get the current user's school ID
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('Not authenticated');
    }
    
    const { data: adminProfile, error: profileError } = await supabase
      .from('profiles')
      .select('school_id')
      .eq('id', user.id as any)
      .single();
      
    if (profileError) {
      console.error("Error fetching admin profile:", profileError);
      throw new Error('Could not fetch admin school information');
    }
    
    // Safe access to school_id property
    const schoolId = safeAccess(adminProfile, 'school_id');
    if (!schoolId) {
      throw new Error('Admin does not have a school assigned');
    }
    
    console.log("Admin school ID:", schoolId);
    
    // Proceed with creating the team member
    console.log("Creating team member with validated email:", userData.email);
    
    // First, let's directly create the user with the auth API
    const { data: authData, error: signUpError } = await supabase.auth.signUp({
      email: userData.email,
      password: userData.password,
      options: {
        data: {
          first_name: userData.firstName || null,
          last_name: userData.lastName || null
        }
      }
    });
    
    if (signUpError) {
      console.error("Error creating auth user:", signUpError);
      throw signUpError;
    }
    
    if (!authData.user || !authData.user.id) {
      console.error("Failed to create user account");
      throw new Error("Failed to create user account");
    }
    
    console.log("Auth user created with ID:", authData.user.id);
    
    // Now call the stored procedure to set up the team member
    // Use type assertion to work around TypeScript limitations with RPC functions
    const { data, error } = await supabase.rpc(
      'finalize_team_member' as any, 
      {
        user_id_param: authData.user.id,
        role_param: userData.role,
        first_name_param: userData.firstName || null,
        last_name_param: userData.lastName || null
      }
    );
    
    if (error) {
      console.error("Error finalizing team member:", error);
      throw error;
    }
    
    // Add logging to help with debugging
    console.log("Team member created successfully:", data);
    return data;
  } catch (error) {
    console.error("Exception creating team member:", error);
    throw error;
  }
};

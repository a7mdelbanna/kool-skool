// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://clacmtyxfdtfgjkozmqf.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsYWNtdHl4ZmR0Zmdqa296bXFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4OTEzMzgsImV4cCI6MjA2NjQ2NzMzOH0.HKKmBmDpQdZ7-hcpj7wM8IJPFVD52T-IfThF9jpjdvY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Type definitions for the application
export interface UserLoginResponse {
  success: boolean;
  message?: string;
  user_id?: string;
  first_name?: string;
  last_name?: string;
  role?: string;
  school_id?: string;
}

export interface SchoolSetupResponse {
  success: boolean;
  message?: string;
  school_id?: string;
  user_id?: string;
}

export interface TeamMemberResponse {
  success: boolean;
  message?: string;
  user_id?: string;
}

export interface CreateStudentResponse {
  success: boolean;
  message?: string;
  student_id?: string;
  user_id?: string;
}

export interface DeleteSubscriptionResponse {
  success: boolean;
  message: string;
  sessions_deleted: number;
}

export interface Course {
  id: string;
  school_id: string;
  name: string;
  lesson_type: string;
  created_at: string;
  updated_at: string;
}

export interface StudentRecord {
  id: string;
  school_id: string;
  user_id: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone: string;
  created_at: string;
  first_name: string;
  last_name: string;
  email: string;
  course_name: string;
  lesson_type: string;
  teacher_first_name: string;
  teacher_last_name: string;
  teacher_email: string;
}

// Helper functions for interacting with the database
export const getStudentsWithDetails = async (schoolId: string): Promise<StudentRecord[]> => {
  const { data, error } = await supabase.rpc('get_students_with_details', {
    p_school_id: schoolId
  });

  if (error) {
    console.error('Error fetching students:', error);
    throw error;
  }

  return data || [];
};

export const getSchoolCourses = async (schoolId: string): Promise<Course[]> => {
  console.log('getSchoolCourses called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS
    const { data, error } = await supabase.rpc('get_school_courses', {
      p_school_id: schoolId
    });

    console.log('RPC get_school_courses result:', { data, error });

    if (error) {
      console.error('Error fetching courses via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched courses:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolCourses:', error);
    throw error;
  }
};

export const getSchoolTeamMembers = async (schoolId: string) => {
  console.log('getSchoolTeamMembers called with schoolId:', schoolId);
  
  try {
    // Use the database function instead of direct query
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Team members RPC result:', { data, error });

    if (error) {
      console.error('Error fetching team members via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched team members:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolTeamMembers:', error);
    throw error;
  }
};

export const getSchoolTeachers = async (schoolId: string) => {
  console.log('getSchoolTeachers called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS consistently
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Teachers RPC result:', { data, error });

    if (error) {
      console.error('Error fetching teachers via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched teachers:', data);
    
    // Filter only teachers and format for compatibility
    const teachers = (data || [])
      .filter(member => member.role === 'teacher')
      .map(teacher => ({
        id: teacher.id,
        first_name: teacher.first_name || '',
        last_name: teacher.last_name || '',
        email: teacher.email || '',
        display_name: teacher.first_name && teacher.last_name 
          ? `${teacher.first_name} ${teacher.last_name}`
          : teacher.email || `ID: ${teacher.id.substring(0, 8)}`
      }));

    console.log('Formatted teachers:', teachers);
    return teachers;
  } catch (error) {
    console.error('Error in getSchoolTeachers:', error);
    throw error;
  }
};

export const getStudentPayments = async (studentId: string) => {
  console.log('getStudentPayments called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_payments', {
      p_student_id: studentId
    });

    console.log('Student payments RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student payments:', error);
      throw error;
    }

    console.log('Successfully fetched student payments:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentPayments:', error);
    throw error;
  }
};

export const addStudentPayment = async (paymentData: {
  student_id: string;
  amount: number;
  currency: string;
  payment_date: string;
  payment_method: string;
  status: string;
  notes?: string;
}) => {
  console.log('addStudentPayment called with:', paymentData);
  
  try {
    const { data, error } = await supabase
      .from('student_payments')
      .insert(paymentData)
      .select()
      .single();

    if (error) {
      console.error('Error adding student payment:', error);
      throw error;
    }

    console.log('Successfully added student payment:', data);
    return data;
  } catch (error) {
    console.error('Error in addStudentPayment:', error);
    throw error;
  }
};

export const deleteStudentPayment = async (paymentId: string) => {
  console.log('deleteStudentPayment called with paymentId:', paymentId);
  
  try {
    const { error } = await supabase
      .from('student_payments')
      .delete()
      .eq('id', paymentId);

    if (error) {
      console.error('Error deleting student payment:', error);
      throw error;
    }

    console.log('Successfully deleted student payment');
  } catch (error) {
    console.error('Error in deleteStudentPayment:', error);
    throw error;
  }
};

export const getStudentSubscriptions = async (studentId: string) => {
  console.log('getStudentSubscriptions called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_subscriptions', {
      p_student_id: studentId
    });

    console.log('Student subscriptions RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student subscriptions:', error);
      throw error;
    }

    console.log('Successfully fetched student subscriptions:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentSubscriptions:', error);
    throw error;
  }
};

// Global tracking for subscription creation to prevent duplicates
const subscriptionCreationTracker = new Map<string, boolean>();

export const addStudentSubscription = async (subscriptionData: {
  student_id: string;
  session_count: number;
  duration_months: number;
  start_date: string;
  schedule: any;
  price_mode: string;
  price_per_session: number | null;
  fixed_price: number | null;
  total_price: number;
  currency: string;
  notes: string;
  status: string;
  // New payment fields
  initial_payment_amount?: number;
  payment_method?: string;
  payment_notes?: string;
}) => {
  console.log('üöÄ ENHANCED: Starting subscription creation with initial payment:', subscriptionData);
  
  // Get user info from localStorage (custom auth system)
  const userString = localStorage.getItem('user');
  if (!userString) {
    console.error('‚ùå No user data in localStorage');
    throw new Error('User session expired. Please log in again.');
  }

  const userData = JSON.parse(userString);
  
  if (!userData.id) {
    console.error('‚ùå No user ID found in user data');
    throw new Error('User ID missing. Please log in again.');
  }
  
  if (!userData.schoolId) {
    console.error('‚ùå No school ID found in user data');
    throw new Error('User school information missing. Please contact support.');
  }

  console.log('‚úÖ User authenticated successfully:', {
    userId: userData.id,
    schoolId: userData.schoolId,
    role: userData.role
  });
  
  try {
    // Call the enhanced function with payment support
    const { data, error } = await supabase.rpc('add_student_subscription', {
      p_student_id: subscriptionData.student_id,
      p_session_count: subscriptionData.session_count,
      p_duration_months: subscriptionData.duration_months,
      p_start_date: subscriptionData.start_date,
      p_schedule: subscriptionData.schedule,
      p_price_mode: subscriptionData.price_mode,
      p_price_per_session: subscriptionData.price_per_session,
      p_fixed_price: subscriptionData.fixed_price,
      p_total_price: subscriptionData.total_price,
      p_currency: subscriptionData.currency,
      p_notes: subscriptionData.notes,
      p_status: subscriptionData.status,
      p_current_user_id: userData.id,
      p_current_school_id: userData.schoolId,
      // New payment parameters
      p_initial_payment_amount: subscriptionData.initial_payment_amount,
      p_payment_method: subscriptionData.payment_method,
      p_payment_notes: subscriptionData.payment_notes
    });

    if (error) {
      console.error('‚ùå Error from RPC function:', error);
      throw new Error(error.message || 'Failed to create subscription with payment');
    }

    console.log('‚úÖ Subscription with initial payment created successfully:', data);
    return data;
    
  } catch (error) {
    console.error('‚ùå Unexpected error in addStudentSubscription:', error);
    throw error;
  }
};

export const deleteStudentSubscription = async (subscriptionId: string) => {
  console.log('üóëÔ∏è USING DATABASE FUNCTION: deleteStudentSubscription called with subscriptionId:', subscriptionId);
  
  if (!subscriptionId) {
    console.error('‚ùå No subscription ID provided');
    throw new Error('Subscription ID is required');
  }
  
  try {
    console.log('üîß Calling database function delete_student_subscription...');
    
    // Use the database function which handles all the logic
    const { data, error } = await supabase.rpc('delete_student_subscription', {
      p_subscription_id: subscriptionId
    });

    console.log('üìù Database function result:', { data, error });

    if (error) {
      console.error('‚ùå Error calling database function:', error);
      throw new Error(`Database error: ${error.message}`);
    }

    // Properly type the response data by casting to unknown first, then to our interface
    const response = data as unknown as DeleteSubscriptionResponse;

    // The database function returns a JSON object with success/failure info
    if (!response || !response.success) {
      console.error('‚ùå Database function returned failure:', response);
      throw new Error(response?.message || 'Failed to delete subscription');
    }

    console.log('‚úÖ SUCCESS: Subscription deleted successfully via database function');
    console.log('üìä Sessions deleted:', response.sessions_deleted);
    
    return response;

  } catch (error) {
    console.error('‚ùå Error in deleteStudentSubscription:', error);
    
    // Re-throw with more context if it's a generic error
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('An unexpected error occurred while deleting the subscription');
  }
};

export const addLessonSessions = async (sessions: Array<{
  subscription_id: string;
  student_id: string;
  scheduled_date: string;
  duration_minutes?: number;
  status?: string;
  payment_status?: string;
  cost: number;
  notes?: string;
}>) => {
  console.log('addLessonSessions called with enhanced duplicate prevention:', sessions);
  
  try {
    const { data, error } = await supabase
      .from('lesson_sessions')
      .insert(sessions)
      .select();

    if (error) {
      console.error('Error adding lesson sessions with enhanced prevention:', error);
      throw error;
    }

    console.log('Successfully added lesson sessions with enhanced prevention:', data);
    return data;
  } catch (error) {
    console.error('Error in addLessonSessions with enhanced prevention:', error);
    throw error;
  }
};

export const getStudentLessonSessions = async (studentId: string) => {
  console.log('getStudentLessonSessions called with COMPREHENSIVE VALIDATION for studentId:', studentId);
  
  try {
    // Enhanced logging for session retrieval with comprehensive database structure
    console.log('=== FETCHING SESSIONS WITH COMPREHENSIVE VALIDATION ===');
    console.log('Fetching lesson sessions for student:', studentId);
    
    // Use direct RPC call with comprehensive error handling
    const { data, error } = await supabase.rpc('get_lesson_sessions' as any, {
      p_student_id: studentId
    });

    console.log('Lesson sessions RPC result with comprehensive validation:', { data, error });

    if (error) {
      console.error('‚ùå Error fetching lesson sessions via RPC:', error);
      throw error;
    }

    // Comprehensive logging and validation for retrieved sessions
    if (data && data.length > 0) {
      console.log(`‚úÖ Successfully fetched ${data.length} lesson sessions with comprehensive validation`);
      
      // Comprehensive session validation and logging
      const sessionSummary = data.map((session, index) => ({
        position: index + 1,
        id: session.id,
        scheduled_date: session.scheduled_date,
        status: session.status,
        notes: session.notes,
        index_in_sub: session.index_in_sub,
        subscription_id: session.subscription_id
      }));
      
      console.log('Comprehensive session summary:', sessionSummary);
      
      // Comprehensive duplicate detection with database constraint validation
      const dateMap = new Map();
      const duplicates: any[] = [];
      
      data.forEach((session, index) => {
        const dateKey = session.scheduled_date;
        if (dateMap.has(dateKey)) {
          console.error('üö´ CRITICAL: Duplicate session detected - Database constraints failed!', {
            position: index + 1,
            existing: dateMap.get(dateKey),
            duplicate: session,
            message: 'This should not happen with the comprehensive database constraints'
          });
          duplicates.push(session);
        } else {
          dateMap.set(dateKey, session);
        }
      });
      
      if (duplicates.length > 0) {
        console.error('üö® CRITICAL DATABASE INTEGRITY ISSUE:', {
          duplicateCount: duplicates.length,
          message: 'Database constraints and triggers are not working as expected',
          duplicates: duplicates
        });
      } else {
        console.log('‚úÖ ALL SESSIONS VALIDATED - Comprehensive duplicate prevention working correctly');
      }
      
    } else {
      console.log('‚ÑπÔ∏è  No lesson sessions found for student:', studentId);
    }

    return data || [];
  } catch (error) {
    console.error('‚ùå Error in getStudentLessonSessions with comprehensive validation:', error);
    throw error;
  }
};

export const updateLessonSessionStatus = async (sessionId: string, status: string) => {
  console.log('updateLessonSessionStatus called with:', { sessionId, status });
  
  try {
    const { error } = await supabase
      .from('lesson_sessions')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('id', sessionId);

    if (error) {
      console.error('Error updating lesson session status:', error);
      throw error;
    }

    console.log('Successfully updated lesson session status');
  } catch (error) {
    console.error('Error in updateLessonSessionStatus:', error);
    throw error;
  }
};

export const createStudent = async (studentData: {
  student_email: string;
  student_password: string;
  first_name: string;
  last_name: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone?: string;
}): Promise<CreateStudentResponse> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_student`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(studentData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};

export const createCourse = async (courseData: {
  school_id: string;
  course_name: string;
  lesson_type: string;
}): Promise<Course> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_course`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(courseData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};


// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://clacmtyxfdtfgjkozmqf.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNsYWNtdHl4ZmR0Zmdqa296bXFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA4OTEzMzgsImV4cCI6MjA2NjQ2NzMzOH0.HKKmBmDpQdZ7-hcpj7wM8IJPFVD52T-IfThF9jpjdvY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Type definitions for the application
export interface UserLoginResponse {
  success: boolean;
  message?: string;
  user_id?: string;
  first_name?: string;
  last_name?: string;
  role?: string;
  school_id?: string;
}

export interface SchoolSetupResponse {
  success: boolean;
  message?: string;
  school_id?: string;
  user_id?: string;
}

export interface TeamMemberResponse {
  success: boolean;
  message?: string;
  user_id?: string;
}

export interface CreateStudentResponse {
  success: boolean;
  message?: string;
  student_id?: string;
  user_id?: string;
}

export interface DeleteSubscriptionResponse {
  success: boolean;
  message: string;
  sessions_deleted: number;
}

export interface Course {
  id: string;
  school_id: string;
  name: string;
  lesson_type: string;
  created_at: string;
  updated_at: string;
}

export interface StudentRecord {
  id: string;
  school_id: string;
  user_id: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone: string;
  created_at: string;
  first_name: string;
  last_name: string;
  email: string;
  course_name: string;
  lesson_type: string;
  teacher_first_name: string;
  teacher_last_name: string;
  teacher_email: string;
}

// Helper functions for interacting with the database
export const getStudentsWithDetails = async (schoolId: string): Promise<StudentRecord[]> => {
  const { data, error } = await supabase.rpc('get_students_with_details', {
    p_school_id: schoolId
  });

  if (error) {
    console.error('Error fetching students:', error);
    throw error;
  }

  return data || [];
};

export const getSchoolCourses = async (schoolId: string): Promise<Course[]> => {
  console.log('getSchoolCourses called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS
    const { data, error } = await supabase.rpc('get_school_courses', {
      p_school_id: schoolId
    });

    console.log('RPC get_school_courses result:', { data, error });

    if (error) {
      console.error('Error fetching courses via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched courses:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolCourses:', error);
    throw error;
  }
};

export const getSchoolTeamMembers = async (schoolId: string) => {
  console.log('getSchoolTeamMembers called with schoolId:', schoolId);
  
  try {
    // Use the database function instead of direct query
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Team members RPC result:', { data, error });

    if (error) {
      console.error('Error fetching team members via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched team members:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getSchoolTeamMembers:', error);
    throw error;
  }
};

export const getSchoolTeachers = async (schoolId: string) => {
  console.log('getSchoolTeachers called with schoolId:', schoolId);
  
  try {
    // Use the RPC function to bypass RLS consistently
    const { data, error } = await supabase.rpc('get_team_members', {
      p_school_id: schoolId
    });

    console.log('Teachers RPC result:', { data, error });

    if (error) {
      console.error('Error fetching teachers via RPC:', error);
      throw error;
    }

    console.log('Successfully fetched teachers:', data);
    
    // Filter only teachers and format for compatibility
    const teachers = (data || [])
      .filter(member => member.role === 'teacher')
      .map(teacher => ({
        id: teacher.id,
        first_name: teacher.first_name || '',
        last_name: teacher.last_name || '',
        email: teacher.email || '',
        display_name: teacher.first_name && teacher.last_name 
          ? `${teacher.first_name} ${teacher.last_name}`
          : teacher.email || `ID: ${teacher.id.substring(0, 8)}`
      }));

    console.log('Formatted teachers:', teachers);
    return teachers;
  } catch (error) {
    console.error('Error in getSchoolTeachers:', error);
    throw error;
  }
};

export const getStudentPayments = async (studentId: string) => {
  console.log('getStudentPayments called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_payments', {
      p_student_id: studentId
    });

    console.log('Student payments RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student payments:', error);
      throw error;
    }

    console.log('Successfully fetched student payments:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentPayments:', error);
    throw error;
  }
};

export const addStudentPayment = async (paymentData: {
  student_id: string;
  amount: number;
  currency: string;
  payment_date: string;
  payment_method: string;
  status: string;
  notes?: string;
}) => {
  console.log('addStudentPayment called with:', paymentData);
  
  try {
    const { data, error } = await supabase
      .from('student_payments')
      .insert(paymentData)
      .select()
      .single();

    if (error) {
      console.error('Error adding student payment:', error);
      throw error;
    }

    console.log('Successfully added student payment:', data);
    return data;
  } catch (error) {
    console.error('Error in addStudentPayment:', error);
    throw error;
  }
};

export const deleteStudentPayment = async (paymentId: string) => {
  console.log('deleteStudentPayment called with paymentId:', paymentId);
  
  try {
    const { error } = await supabase
      .from('student_payments')
      .delete()
      .eq('id', paymentId);

    if (error) {
      console.error('Error deleting student payment:', error);
      throw error;
    }

    console.log('Successfully deleted student payment');
  } catch (error) {
    console.error('Error in deleteStudentPayment:', error);
    throw error;
  }
};

export const getStudentSubscriptions = async (studentId: string) => {
  console.log('getStudentSubscriptions called with studentId:', studentId);
  
  try {
    const { data, error } = await supabase.rpc('get_student_subscriptions', {
      p_student_id: studentId
    });

    console.log('Student subscriptions RPC result:', { data, error });

    if (error) {
      console.error('Error fetching student subscriptions:', error);
      throw error;
    }

    console.log('Successfully fetched student subscriptions:', data);
    return data || [];
  } catch (error) {
    console.error('Error in getStudentSubscriptions:', error);
    throw error;
  }
};

// Global tracking for subscription creation to prevent duplicates
const subscriptionCreationTracker = new Map<string, boolean>();

export const addStudentSubscription = async (subscriptionData: {
  student_id: string;
  session_count: number;
  duration_months: number;
  start_date: string;
  schedule: any;
  price_mode: string;
  price_per_session?: number;
  fixed_price?: number;
  total_price: number;
  currency: string;
  notes?: string;
  status?: string;
}) => {
  // Create a unique key for this subscription request
  const subscriptionKey = `${subscriptionData.student_id}-${subscriptionData.start_date}-${subscriptionData.session_count}-${JSON.stringify(subscriptionData.schedule)}`;
  
  console.log('🔍 DUPLICATE PREVENTION: Checking for ongoing subscription creation:', subscriptionKey);
  
  // Check if this exact subscription is already being created
  if (subscriptionCreationTracker.has(subscriptionKey)) {
    console.error('🚫 DUPLICATE CALL PREVENTED: Subscription creation already in progress for:', subscriptionKey);
    throw new Error('Subscription creation already in progress. Please wait.');
  }
  
  // Mark this subscription as being created
  subscriptionCreationTracker.set(subscriptionKey, true);
  
  try {
    console.log('=== STARTING SUBSCRIPTION CREATION WITH DUPLICATE PREVENTION ===');
    console.log('addStudentSubscription called with DUPLICATE PREVENTION:', subscriptionData);
    
    // Get current user from localStorage for validation
    const userString = localStorage.getItem('user');
    if (!userString) {
      throw new Error('User not authenticated');
    }
    
    const user = JSON.parse(userString);
    console.log('Current user for subscription:', user);
    
    console.log('=== CALLING FIXED add_student_subscription RPC WITH DUPLICATE PREVENTION ===');
    console.log('About to call add_student_subscription RPC with parameters:', {
      p_student_id: subscriptionData.student_id,
      p_session_count: subscriptionData.session_count,
      p_duration_months: subscriptionData.duration_months,
      p_start_date: subscriptionData.start_date,
      p_schedule: subscriptionData.schedule,
      p_current_user_id: user.id,
      p_current_school_id: user.schoolId
    });
    
    // Add a small delay to prevent rapid successive calls
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Use the fixed RPC function with comprehensive duplicate prevention
    const { data, error } = await supabase.rpc('add_student_subscription', {
      p_student_id: subscriptionData.student_id,
      p_session_count: subscriptionData.session_count,
      p_duration_months: subscriptionData.duration_months,
      p_start_date: subscriptionData.start_date,
      p_schedule: subscriptionData.schedule,
      p_price_mode: subscriptionData.price_mode,
      p_price_per_session: subscriptionData.price_per_session || null,
      p_fixed_price: subscriptionData.fixed_price || null,
      p_total_price: subscriptionData.total_price,
      p_currency: subscriptionData.currency,
      p_notes: subscriptionData.notes || null,
      p_status: subscriptionData.status || 'active',
      p_current_user_id: user.id,
      p_current_school_id: user.schoolId
    });

    if (error) {
      console.error('❌ Error adding student subscription via RPC:', error);
      
      // Enhanced error handling
      if (error.message && error.message.includes('duplicate key value violates unique constraint')) {
        throw new Error('Cannot create subscription: A session already exists at this time. Please choose a different schedule.');
      }
      
      if (error.message && error.message.includes('Duplicate session prevented')) {
        throw new Error('Cannot create subscription: Some sessions would conflict with existing ones. Please check the student\'s current schedule.');
      }
      
      // Generic error fallback
      throw new Error(error.message || 'Failed to create subscription');
    }

    if (!data || (Array.isArray(data) && data.length === 0)) {
      throw new Error('Subscription creation failed: No data returned from server');
    }

    console.log('✅ Successfully added student subscription with duplicate prevention:', data);
    console.log('🎉 SUBSCRIPTION CREATED SUCCESSFULLY with client-side duplicate prevention');
    
    // Return the first item from the array since RPC returns an array
    return Array.isArray(data) && data.length > 0 ? data[0] : data;
  } catch (error) {
    console.error('❌ Error in addStudentSubscription with duplicate prevention:', error);
    
    // Re-throw with more context if it's a generic error
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('An unexpected error occurred while creating the subscription');
  } finally {
    // Always remove the tracking key after completion (success or failure)
    console.log('🧹 CLEANUP: Removing subscription creation tracking for:', subscriptionKey);
    subscriptionCreationTracker.delete(subscriptionKey);
  }
};

export const deleteStudentSubscription = async (subscriptionId: string) => {
  console.log('🗑️ SIMPLIFIED: deleteStudentSubscription called with subscriptionId:', subscriptionId);
  
  if (!subscriptionId) {
    console.error('❌ No subscription ID provided');
    throw new Error('Subscription ID is required');
  }
  
  try {
    // Get current user data from localStorage for authentication
    const userString = localStorage.getItem('user');
    if (!userString) {
      console.error('❌ No user found in localStorage');
      throw new Error('User not authenticated - please log in again');
    }

    const user = JSON.parse(userString);
    console.log('✅ Found user in localStorage:', { 
      id: user.id, 
      schoolId: user.schoolId, 
      role: user.role 
    });

    if (!user.id || !user.schoolId) {
      console.error('❌ Invalid user data:', user);
      throw new Error('Invalid user data - please log in again');
    }

    console.log('🔧 Checking if subscription exists before deletion...');
    
    // First, check if the subscription exists using maybeSingle() to avoid errors
    const { data: subscriptionCheck, error: checkError } = await supabase
      .from('subscriptions')
      .select(`
        id,
        student_id,
        students!inner(
          id,
          school_id
        )
      `)
      .eq('id', subscriptionId)
      .maybeSingle();

    if (checkError) {
      console.error('❌ Error checking subscription existence:', checkError);
      throw new Error('Failed to verify subscription');
    }

    // If subscription doesn't exist, consider it already deleted
    if (!subscriptionCheck) {
      console.log('⚠️ Subscription not found - may already be deleted');
      return {
        success: true,
        message: 'Subscription already deleted or not found',
        sessions_deleted: 0
      };
    }

    // Verify user has permission (same school)
    if (subscriptionCheck.students.school_id !== user.schoolId) {
      console.error('❌ School mismatch:', {
        subscriptionSchool: subscriptionCheck.students.school_id,
        userSchool: user.schoolId
      });
      throw new Error('Access denied: You do not have permission to delete this subscription');
    }

    // Verify user role
    if (!['admin', 'teacher'].includes(user.role)) {
      console.error('❌ Invalid role:', user.role);
      throw new Error('Access denied: Only admins and teachers can delete subscriptions');
    }

    console.log('✅ Permission checks passed, proceeding with deletion');

    // Delete associated lesson sessions first
    const { error: sessionsDeleteError } = await supabase
      .from('lesson_sessions')
      .delete()
      .eq('subscription_id', subscriptionId);

    if (sessionsDeleteError) {
      console.error('❌ Error deleting lesson sessions:', sessionsDeleteError);
      throw new Error(`Failed to delete lesson sessions: ${sessionsDeleteError.message}`);
    }

    console.log('✅ Lesson sessions deleted successfully');

    // Delete the subscription
    const { error: subscriptionDeleteError } = await supabase
      .from('subscriptions')
      .delete()
      .eq('id', subscriptionId);

    if (subscriptionDeleteError) {
      console.error('❌ Error deleting subscription:', subscriptionDeleteError);
      throw new Error(`Failed to delete subscription: ${subscriptionDeleteError.message}`);
    }

    console.log('✅ SUCCESS: Subscription deleted successfully');
    
    return {
      success: true,
      message: 'Subscription deleted successfully',
      sessions_deleted: 'Unknown' // We don't get the count with direct delete
    };

  } catch (error) {
    console.error('❌ Error in deleteStudentSubscription:', error);
    
    // Re-throw with more context if it's a generic error
    if (error instanceof Error) {
      throw error;
    }
    
    throw new Error('An unexpected error occurred while deleting the subscription');
  }
};

export const addLessonSessions = async (sessions: Array<{
  subscription_id: string;
  student_id: string;
  scheduled_date: string;
  duration_minutes?: number;
  status?: string;
  payment_status?: string;
  cost: number;
  notes?: string;
}>) => {
  console.log('addLessonSessions called with enhanced duplicate prevention:', sessions);
  
  try {
    const { data, error } = await supabase
      .from('lesson_sessions')
      .insert(sessions)
      .select();

    if (error) {
      console.error('Error adding lesson sessions with enhanced prevention:', error);
      throw error;
    }

    console.log('Successfully added lesson sessions with enhanced prevention:', data);
    return data;
  } catch (error) {
    console.error('Error in addLessonSessions with enhanced prevention:', error);
    throw error;
  }
};

export const getStudentLessonSessions = async (studentId: string) => {
  console.log('getStudentLessonSessions called with COMPREHENSIVE VALIDATION for studentId:', studentId);
  
  try {
    // Enhanced logging for session retrieval with comprehensive database structure
    console.log('=== FETCHING SESSIONS WITH COMPREHENSIVE VALIDATION ===');
    console.log('Fetching lesson sessions for student:', studentId);
    
    // Use direct RPC call with comprehensive error handling
    const { data, error } = await supabase.rpc('get_lesson_sessions' as any, {
      p_student_id: studentId
    });

    console.log('Lesson sessions RPC result with comprehensive validation:', { data, error });

    if (error) {
      console.error('❌ Error fetching lesson sessions via RPC:', error);
      throw error;
    }

    // Comprehensive logging and validation for retrieved sessions
    if (data && data.length > 0) {
      console.log(`✅ Successfully fetched ${data.length} lesson sessions with comprehensive validation`);
      
      // Comprehensive session validation and logging
      const sessionSummary = data.map((session, index) => ({
        position: index + 1,
        id: session.id,
        scheduled_date: session.scheduled_date,
        status: session.status,
        notes: session.notes,
        index_in_sub: session.index_in_sub,
        subscription_id: session.subscription_id
      }));
      
      console.log('Comprehensive session summary:', sessionSummary);
      
      // Comprehensive duplicate detection with database constraint validation
      const dateMap = new Map();
      const duplicates: any[] = [];
      
      data.forEach((session, index) => {
        const dateKey = session.scheduled_date;
        if (dateMap.has(dateKey)) {
          console.error('🚫 CRITICAL: Duplicate session detected - Database constraints failed!', {
            position: index + 1,
            existing: dateMap.get(dateKey),
            duplicate: session,
            message: 'This should not happen with the comprehensive database constraints'
          });
          duplicates.push(session);
        } else {
          dateMap.set(dateKey, session);
        }
      });
      
      if (duplicates.length > 0) {
        console.error('🚨 CRITICAL DATABASE INTEGRITY ISSUE:', {
          duplicateCount: duplicates.length,
          message: 'Database constraints and triggers are not working as expected',
          duplicates: duplicates
        });
      } else {
        console.log('✅ ALL SESSIONS VALIDATED - Comprehensive duplicate prevention working correctly');
      }
      
    } else {
      console.log('ℹ️  No lesson sessions found for student:', studentId);
    }

    return data || [];
  } catch (error) {
    console.error('❌ Error in getStudentLessonSessions with comprehensive validation:', error);
    throw error;
  }
};

export const updateLessonSessionStatus = async (sessionId: string, status: string) => {
  console.log('updateLessonSessionStatus called with:', { sessionId, status });
  
  try {
    const { error } = await supabase
      .from('lesson_sessions')
      .update({ status, updated_at: new Date().toISOString() })
      .eq('id', sessionId);

    if (error) {
      console.error('Error updating lesson session status:', error);
      throw error;
    }

    console.log('Successfully updated lesson session status');
  } catch (error) {
    console.error('Error in updateLessonSessionStatus:', error);
    throw error;
  }
};

export const createStudent = async (studentData: {
  student_email: string;
  student_password: string;
  first_name: string;
  last_name: string;
  teacher_id: string;
  course_id: string;
  age_group: string;
  level: string;
  phone?: string;
}): Promise<CreateStudentResponse> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_student`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(studentData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};

export const createCourse = async (courseData: {
  school_id: string;
  course_name: string;
  lesson_type: string;
}): Promise<Course> => {
  // Get current user data from localStorage
  const userString = localStorage.getItem('user');
  if (!userString) {
    throw new Error('No user found');
  }

  const user = JSON.parse(userString);
  
  // Call the edge function
  const response = await fetch(`${SUPABASE_URL}/functions/v1/create_course`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${SUPABASE_PUBLISHABLE_KEY}`,
      'x-user-id': user.id,
      'x-school-id': user.schoolId,
      'x-user-role': user.role,
    },
    body: JSON.stringify(courseData),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return await response.json();
};
